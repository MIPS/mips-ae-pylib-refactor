"""Report analysis and metrics extraction.

This module provides functionality to parse and analyze performance reports
generated by Atlas Explorer experiments.
"""

import json
import re
import locale
from pathlib import Path
from typing import Dict, Any, List, Optional, Union

from ..utils.exceptions import ExperimentError


class SummaryReport:
    """Analyzes Atlas Explorer summary performance reports.
    
    This class provides methods to extract performance metrics, cycles,
    instructions, and other statistics from experiment summary reports.
    """
    
    def __init__(self, json_file: Union[str, Path]):
        """Initialize summary report from JSON file.
        
        Args:
            json_file: Path to JSON summary report file
            
        Raises:
            ExperimentError: If report file cannot be loaded or parsed
        """
        self.json_file = Path(json_file)
        
        if not self.json_file.exists():
            raise ExperimentError(f"Summary report file does not exist: {json_file}")
        
        try:
            with open(self.json_file) as f:
                json_data = json.load(f)
            
            if "Statistics" not in json_data or "Summary Performance Report" not in json_data["Statistics"]:
                raise ExperimentError(f"Invalid summary report format: {json_file}")
            
            self.summarydata = json_data["Statistics"]["Summary Performance Report"]
            
            # Remove the "ordered_key" entry if it exists
            self.summarydata.pop("ordered_keys", None)
            
            # Extract key metrics
            self._extract_core_metrics()
            
        except json.JSONDecodeError as e:
            raise ExperimentError(f"Invalid JSON in summary report {json_file}: {e}")
        except Exception as e:
            raise ExperimentError(f"Error loading summary report {json_file}: {e}")
    
    def _extract_core_metrics(self) -> None:
        """Extract core performance metrics from the summary data."""
        try:
            self.totalcycles = self.summarydata["Total Cycles Consumed"]["val"]
        except KeyError:
            raise ExperimentError("Summary report missing 'Total Cycles Consumed' metric")
        
        # Handle different instruction count keys
        if "Total Instructions Retired" in self.summarydata:
            self.totalinsts = self.summarydata["Total Instructions Retired"]["val"]
        elif "Total Instructions Retired (All Threads)" in self.summarydata:
            self.totalinsts = self.summarydata["Total Instructions Retired (All Threads)"]["val"]
        else:
            raise ExperimentError("Summary report missing instruction count metrics")
    
    def get_total_cycles(self) -> int:
        """Get the total cycles from the summary report.
        
        Returns:
            Total cycles consumed by the experiment
        """
        return self.totalcycles
    
    def get_total_instructions(self) -> int:
        """Get the total instructions from the summary report.
        
        Returns:
            Total instructions retired by the experiment
        """
        return self.totalinsts
    
    def get_ipc(self) -> float:
        """Calculate Instructions Per Cycle (IPC).
        
        Returns:
            IPC ratio (instructions / cycles)
        """
        if self.totalcycles == 0:
            return 0.0
        return self.totalinsts / self.totalcycles
    
    def get_metric_keys(self, regex_pattern: Optional[str] = None) -> List[str]:
        """Get list of metric keys, optionally filtered by regex.
        
        Args:
            regex_pattern: Optional regex pattern to filter keys
            
        Returns:
            List of metric keys from the summary report
        """
        all_keys = list(self.summarydata.keys())
        
        if regex_pattern is None:
            return all_keys
        
        try:
            pattern = re.compile(regex_pattern)
            return [key for key in all_keys if pattern.search(key)]
        except re.error:
            print(f"Invalid regex pattern: {regex_pattern}")
            return all_keys
    
    def get_metric_value(self, key: str) -> Any:
        """Get the value of a specific metric key.
        
        Args:
            key: Metric key to retrieve
            
        Returns:
            Metric value
            
        Raises:
            ExperimentError: If key does not exist
        """
        if key not in self.summarydata:
            raise ExperimentError(f"Metric key '{key}' not found in summary report")
        
        return self.summarydata[key]["val"]
    
    def get_metric_info(self, key: str) -> Dict[str, Any]:
        """Get complete metric information including value and metadata.
        
        Args:
            key: Metric key to retrieve
            
        Returns:
            Complete metric dictionary with value and metadata
            
        Raises:
            ExperimentError: If key does not exist
        """
        if key not in self.summarydata:
            raise ExperimentError(f"Metric key '{key}' not found in summary report")
        
        return self.summarydata[key]
    
    def print_metrics(self, regex_pattern: Optional[str] = None) -> None:
        """Print all metrics, optionally filtered by regex pattern.
        
        Args:
            regex_pattern: Optional regex pattern to filter which metrics to print
        """
        keys = self.get_metric_keys(regex_pattern)
        
        # Set up locale for number formatting
        try:
            locale.setlocale(locale.LC_ALL, "")
        except locale.Error:
            # Fallback if locale setting fails
            pass
        
        print(f"\\nSummary Report Metrics ({len(keys)} metrics):")
        print("=" * 50)
        
        for key in keys:
            try:
                value = self.get_metric_value(key)
                
                # Format value based on type
                if isinstance(value, int):
                    try:
                        value_str = locale.format_string("%d", value, grouping=True)
                    except (ValueError, locale.Error):
                        value_str = str(value)
                elif isinstance(value, float):
                    try:
                        value_str = locale.format_string("%.6f", value, grouping=True)
                    except (ValueError, locale.Error):
                        value_str = f"{value:.6f}"
                else:
                    value_str = str(value)
                
                print(f"{key}: {value_str}")
                
            except Exception as e:
                print(f"{key}: <error: {e}>")
    
    def export_metrics(self, output_file: Union[str, Path], regex_pattern: Optional[str] = None) -> None:
        """Export metrics to a JSON file.
        
        Args:
            output_file: Path to output JSON file
            regex_pattern: Optional regex pattern to filter which metrics to export
        """
        keys = self.get_metric_keys(regex_pattern)
        metrics = {}
        
        for key in keys:
            try:
                metrics[key] = self.get_metric_info(key)
            except Exception as e:
                metrics[key] = {"error": str(e)}
        
        output_path = Path(output_file)
        output_path.parent.mkdir(parents=True, exist_ok=True)
        
        with open(output_path, 'w') as f:
            json.dump({
                "source_report": str(self.json_file),
                "total_cycles": self.totalcycles,
                "total_instructions": self.totalinsts,
                "ipc": self.get_ipc(),
                "metrics": metrics
            }, f, indent=2)
    
    def get_cache_metrics(self) -> Dict[str, Any]:
        """Extract cache-related performance metrics.
        
        Returns:
            Dictionary of cache performance metrics
        """
        cache_metrics = {}
        cache_patterns = [
            r".*[Cc]ache.*[Hh]it.*",
            r".*[Cc]ache.*[Mm]iss.*",
            r".*L1.*",
            r".*L2.*",
            r".*L3.*"
        ]
        
        for pattern in cache_patterns:
            keys = self.get_metric_keys(pattern)
            for key in keys:
                try:
                    cache_metrics[key] = self.get_metric_value(key)
                except Exception:
                    continue
        
        return cache_metrics
    
    def get_branch_metrics(self) -> Dict[str, Any]:
        """Extract branch prediction performance metrics.
        
        Returns:
            Dictionary of branch prediction metrics
        """
        branch_metrics = {}
        branch_patterns = [
            r".*[Bb]ranch.*",
            r".*[Pp]rediction.*"
        ]
        
        for pattern in branch_patterns:
            keys = self.get_metric_keys(pattern)
            for key in keys:
                try:
                    branch_metrics[key] = self.get_metric_value(key)
                except Exception:
                    continue
        
        return branch_metrics
